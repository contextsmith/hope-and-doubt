// THIS FILE IS AUTOMATICALLY GENERATED - DO NOT EDIT
// SEE THE generateDoubt SCRIPT IN THE TOP LEVEL SOURCE FOLDER
package com.martiansoftware.validation;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Objects;
import java.util.Optional;
import java.util.function.Predicate;

/**
 * A simple pessimistic validator that throws <code>CheckedValidationException</code>s
 * if validation fails.
 * 
 * @author <a href="http://martylamb.com">Marty Lamb</a>
 */
public class Doubt<T> {

    /**
     * the value that is being validated
     */
    private final T _value;
    
    /**
     * an optional name for the value being validated (only used in exception messages)
     */
    private volatile String _name = "value";
    
    /**
     * Creates a new pessimistic validator for the specified value
     * @param value the value being validated
     */
    private Doubt(T value) {
        _value = value;
    }

    /**
     * Creates a new pessimistic validator for the specified value
     * @param <T> the type of object being validated
     * @param value the value being validated
     * @return a new pessimistic validator for the specified value
     */
    public static <T> Doubt<T> that(T value) {
        return new Doubt(value);
    }
    
    /**
     * Assigns an (optional) name to the value being validated.  This is useful
     * if validating multiple method parameters (for example) so that any exceptions
     * refer to the parameter by name
     * 
     * @param name the name of the value being validated
     * @return 
     */
    public Doubt<T> named(String name) {
        _name = name;
        return this;
    }
    
    /**
     * Returns the value being validated
     * @return the value being validated
     */
    public T value() { return _value; }
    
    /**
     * Pessimistically validates that the value is not null.
     * @return this pessimistic validator
     * @throws CheckedValidationException if validation fails
     */
    public Doubt<T> isNotNull() throws CheckedValidationException {
        if (_value == null) invalid(String.format("%s must not be null", _name));
        return this;
    }

    /**
     * Pessimistically validates that the value is null.
     * @return this pessimistic validator
     * @throws CheckedValidationException if validation fails
     */
    public Doubt<T> isNull() throws CheckedValidationException {
        if (_value != null) invalid("%s must be null", _name);
        return this;
    }

    // checks that the value is optional and is present
    private boolean _isPresent() throws CheckedValidationException  {
        isNotNull();
        if (_value instanceof Optional) return ((Optional) _value).isPresent();
        else invalid("%s is not an Optional; check for isPresent() is not valid.", _name);
        return false; // not reachable but needed to satisfy compiler
    }
    
    /**
     * Pessimistically validates that the value is not present (must be an Optional)
     * @return this pessimistic validator
     * @throws CheckedValidationException if validation fails
     */
    public Doubt<T> isNotPresent() throws CheckedValidationException {
        if (_isPresent()) invalid("%s must not be present", _name);
        return this;
    }
    
    /**
     * Pessimistically validates that the value is present (must be an Optional)
     * @return this pessimistic validator
     * @throws CheckedValidationException if validation fails
     */
    public Doubt<T> isPresent() throws CheckedValidationException {
        if (!_isPresent()) invalid("%s must be present", _name);
        return this;
    }
    
    /**
     * Pessimistically validates that the value is not null or empty.  Emptiness
     * is determined as follows:
     * <ul>
     * <li>A zero-length array is empty.</li>
     * <li>If the object has a boolean isEmpty() method that returns true (e.g., a Collection), it is empty.</li>
     * </ul>
     * @return this pessimistic validator
     * @throws CheckedValidationException if validation fails
     */
    public Doubt<T> isNotNullOrEmpty() throws CheckedValidationException  {
        isNotNull();
        boolean oops = false;
        if (_value.getClass().isArray()) {
            oops = ((Object[]) _value).length == 0;
        } else {
            try {
                Method m = _value.getClass().getMethod("isEmpty");
                if (m.getReturnType().equals(Boolean.TYPE)) {
                    oops = (Boolean) m.invoke(_value);
                } else throw new NoSuchMethodException("unexpected return type: " + m.getReturnType());
            } catch (NoSuchMethodException | IllegalAccessException e) {
                throw new IllegalStateException(String.format("class %s does not provide an accessible boolean isEmpty() method", _value.getClass().getName()), e);
            } catch (InvocationTargetException e) {
                throw new IllegalStateException(String.format("unable to invoke %s.isEmpty()", _value.getClass().getName()), e);
            }
        }
        if (oops) invalid("%s must not be empty", _name);
        return this;
    }

    /**
     * Pessimistically validates that the value is not equal to another Object
     * @return this pessimistic validator
     * @throws CheckedValidationException if validation fails
     */
    public Doubt<T> isNotEqualTo(Object other) throws CheckedValidationException  {
        if (Objects.equals(_value, other)) invalid("%s must not be equal to '%s'", _name, other);
        return this;
    }
    
    /**
     * Pessimistically validates that the value is equal to another Object
     * @return this pessimistic validator
     * @throws CheckedValidationException if validation fails
     */
    public Doubt<T> isEqualTo(Object other) throws CheckedValidationException  {
        if (!Objects.equals(_value, other)) invalid("%s must be equal to '%s'", _name, other);
        return this;
    }

    /**
     * Pessimistically validates that the specified condition is false
     * @param condition the condition to test
     * @param fmt the exception message format string to use if validation fails
     * @param args the exception message format arguments to use if validation fails
     * @return this pessimistic validator
     * @throws CheckedValidationException if validation fails
     */
    public Doubt<T> isFalse(boolean condition, String fmt, Object... args) throws CheckedValidationException  {
        if (condition) invalid(fmt, args);
        return this;
    }
    
    /**
     * Pessimistically validates that the specified condition is false
     * @param condition the condition to test
     * @return this pessimistic validator
     * @throws CheckedValidationException if validation fails
     */
    public Doubt<T> isFalse(boolean condition) throws CheckedValidationException {
        return isFalse(condition, "custom validation logic must evaluate to false");
    }
    
    /**
     * Pessimistically validates that the specified Predicate evaluates to false
     * @param p the Predicate to test
     * @return this pessimistic validator
     * @throws CheckedValidationException if validation fails
     */
    public Doubt<T> isFalse(Predicate<T> p) throws CheckedValidationException {
        return isFalse(p.test(_value));
    }
    
    /**
     * Pessimistically validates that the specified Predicate evaluates to true
     * @param p the Predicate to test
     * @param fmt the exception message format string to use if validation fails
     * @param args the exception message format arguments to use if validation fails
     * @return this pessimistic validator
     * @throws CheckedValidationException if validation fails
     */
    public Doubt<T> isFalse(Predicate<T> p, String fmt, Object... args) throws CheckedValidationException {
        return isFalse(p.test(_value), fmt, args);
    }

    /**
     * Pessimistically validates that the specified condition is true
     * @param condition the condition to test
     * @param fmt the exception message format string to use if validation fails
     * @param args the exception message format arguments to use if validation fails
     * @return this pessimistic validator
     * @throws CheckedValidationException if validation fails
     */
    public Doubt<T> isTrue(boolean condition, String fmt, Object... args) throws CheckedValidationException {
        if (!condition) invalid(fmt, args);
        return this;
    }

    /**
     * Pessimistically validates that the specified condition is true
     * @param condition the condition to test
     * @return this pessimistic validator
     * @throws CheckedValidationException if validation fails
     */
    public Doubt<T> isTrue(boolean condition) throws CheckedValidationException {
        return isTrue(condition, "custom validation logic must evaluate to true");
    }

    /**
     * Pessimistically validates that the specified Predicate evaluates to true
     * @param p the Predicate to test
     * @return this pessimistic validator
     * @throws CheckedValidationException if validation fails
     */
    public Doubt<T> isTrue(Predicate<T> p) throws CheckedValidationException {
        return isTrue(p.test(_value));
    }
    
    /**
     * Pessimistically validates that the specified Predicate evaluates to true
     * @param p the Predicate to test
     * @param fmt the exception message format string to use if validation fails
     * @param args the exception message format arguments to use if validation fails
     * @return this pessimistic validator
     * @throws CheckedValidationException if validation fails
     */
    public Doubt<T> isTrue(Predicate<T> p, String fmt, Object... args) throws CheckedValidationException {
        return isTrue(p.test(_value), fmt, args);
    }
    
    protected void invalid(String fmt, Object... args) throws CheckedValidationException {
        throw new CheckedValidationException(String.format(fmt, args));
    }
}
